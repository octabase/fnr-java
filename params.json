{"name":"Fnr-java","tagline":"A Java implementation for Flexible Naor and Reingold encryption scheme","body":"FNR Cipher\r\n=========\r\nFNR Cipher is a Java implementation for [Flexible Naor and Reingold](http://eprint.iacr.org/2014/421) encryption scheme.\r\n\r\n[![Build Status](https://travis-ci.org/octabase/fnr-java.svg?branch=master)](https://travis-ci.org/octabase/fnr-java) [![Coverage Status](https://coveralls.io/repos/octabase/fnr-java/badge.svg?branch=master&service=github)](https://coveralls.io/github/octabase/fnr-java?branch=master)\r\n\r\n---\r\n\r\nIt's simple. If you give an integer, you get a encrypted integer. This is two-way operation. That means, if you give the encrypted integer also you get the original integer. The FNR algorithm preserves your data size, no expand, no shrink. All operation space limited by key bit length.\r\n\r\nThis method also known as [format preserving encryption](https://en.wikipedia.org/wiki/Format-preserving_encryption). FNR algorithm is useful for small data types (up to 128 bits) such as credit card or user ids.\r\n\r\nFNR uses AES-128 internally in each encryption/decryption rounds. FNR Java contains optimized and minimal AES-128 pure Java cipher. It's may be prefer instead of Java Cryptography Extension in case of performance considerations or JVM limitations. This library don't have any dependencies, it fits for Andorid.\r\n\r\nThe FNR Java library is [binary compatible](https://github.com/octabase/fnr-java/blob/master/src/test/java/io/octa/security/fnr/FNRCipherTest.java#L106-L146) with [reference C implementation](https://github.com/cisco/libfnr).\r\n\r\nFNR Java provides some built-in codecs for basic data types encryption.\r\n\r\n----\r\n\r\n#### Built-In Supported Java Types:\r\n| Java Type    | Codec              | Notes  |\r\n| :----------- | :-------------------|:-------------------------------------------------- |\r\n| Byte         | FNRCodec.BYTE       | NP_SIGN codec not preserve sign.                   |\r\n| Short        | FNRCodec.SHORT      | NP_SIGN codec not preserve sign.                   |\r\n| Character    | FNRCodec.CHAR       | NP_SIGN codec not preserve sign.                   |\r\n| Integer      | FNRCodec.INT        | NP_SIGN codec not preserve sign.                   |\r\n| Float        | FNRCodec.FLOAT      | NP_SIGN_EXP codec not preserve sign and exponent.  |\r\n| Long         | FNRCodec.LONG       | NP_SIGN codec not preserve sign.                   |\r\n| Double       | FNRCodec.DOUBLE     | NP_SIGN_EXP codec not preserve sign and exponent.  |\r\n| BigInteger   | FNRCodec.BIGINT_128 | The acceptable value range are -2^127 to 2^127-1 or 0 to 2^128-1 |\r\n| Date         | FNRCodec.DATE       | -      |\r\n| Inet4Address | FNRCodec.IPV4       | -      |\r\n| Inet6Address | FNRCodec.IPV6       |        |\r\n> **Note:** All numeric codecs run as litte-endian for compatibiliy with other platform like C or Go and preserve sign and exponents as default.\r\n\r\n#### Install [![Maven Central](https://maven-badges.herokuapp.com/maven-central/io.octa.security/fnr/badge.svg)](https://maven-badges.herokuapp.com/maven-central/io.octa.security/fnr)\r\n```xml\r\n<dependency>\r\n\t<groupId>io.octa.security</groupId>\r\n\t<artifactId>fnr</artifactId>\r\n\t<version>1.0.1</version>\r\n</dependency>\r\n```\r\n\r\n#### Usage\r\n```java\r\nString passphrase = \"this is a password\";\r\nString salt = \"this is a salt value\"; // for built-in PBKDF2 key generation.\r\n\r\nbyte[] aesKey = FNRUtils.createAes128KeyWithPBKDF2(passphrase, salt);\r\n\r\n// Integer encryption\r\nFNRKey key = new FNRKey(aesKey, FNRCodec.INT.getRequiredKeyNumBits());\r\nFNRTweak tweak = key.generateTweak(\"this is a tweak value\");\r\n        \r\nint raw = 42;\r\n\r\nint encrypted = FNRCipher.encrypt(FNRCodec.INT, key, tweak, raw);\r\nint decrypted = FNRCipher.decrypt(FNRCodec.INT, key, tweak, encrypted);\r\n\r\nSystem.out.println(\"raw: \" + raw);             // prints 42\r\nSystem.out.println(\"encrypted: \" + encrypted); // prints 1432569698\r\nSystem.out.println(\"decrypted: \" + decrypted); // prints 42\r\n\r\n// IP encryption\r\nkey = new FNRKey(aesKey, FNRCodec.IPV4.getRequiredKeyNumBits());\r\ntweak = key.generateTweak(\"this is a tweak value\");\r\n\r\nInet4Address rawIP = (Inet4Address) Inet4Address.getByName(\"8.4.4.2\");\r\n\r\nInet4Address encryptedIP = FNRCipher.encrypt(FNRCodec.IPV4, key, tweak, rawIP);\r\nInet4Address decryptedIP = FNRCipher.decrypt(FNRCodec.IPV4, key, tweak, encryptedIP);\r\n\r\nSystem.out.println(\"raw: \" + rawIP);             // prints 8.4.4.2\r\nSystem.out.println(\"encrypted: \" + encryptedIP); // prints 25.123.159.248\r\nSystem.out.println(\"decrypted: \" + decryptedIP); // prints 8.4.4.2\r\n```\r\n\r\n#### Performance\r\n| Library        | AES Encryption Method | Encryption       | Decryption       | Notes  |\r\n| :------------- | :-------------------- | ---------------: | ---------------: | :----- |\r\n| [Reference C implementaion](https://github.com/cisco/libfnr) | OpenSSL               | 229141.720 ops/s | 230386.135 ops/s | OpenSSL uses [CPU AES Extension](https://en.wikipedia.org/wiki/AES_instruction_set)  |\r\n| FNR Java       | Built-In              | 198160.740 ops/s | 202775.251 ops/s | AES encryption with built-in minimal, optimized cipher |\r\n| [Java binding for Reference C implementaion](https://github.com/cisco/jfnr) | OpenSSL               | 105766.458 ops/s | 106495.132 ops/s | I think the cause of bottleneck is JNI round-trip overhead. |\r\n| FNR Java       | JCE                   |  82998.094 ops/s |  81175.897 ops/s | AES encryption with standard Java Cryptography Extension |\r\n\r\n> Tested on Intel(R) Core(TM) i7-4700MQ CPU @ 2.40GHz.\r\n>\r\n> Java Benchmark: [FNRCipherBenchmarkTest.java](https://github.com/octabase/fnr-java/blob/master/src/test/java/io/octa/security/fnr/FNRCipherBenchmarkTest.java)\r\n> ```\r\n> JMH 1.11.3 (released 3 days ago)\r\n> VM version: JDK 1.8.0_66, VM 25.66-b17\r\n> VM invoker: /usr/lib/jvm/java-8-oracle/jre/bin/java\r\n> VM options: <none>\r\n> Warmup: 5 iterations, 1 s each\r\n> Measurement: 5 iterations, 1 s each\r\n> Timeout: 10 min per iteration\r\n> Threads: 1 thread, will synchronize iterations\r\n> Benchmark mode: Throughput, ops/time\r\n> ```\r\n>\r\n> C Benchmark: [bench.c](https://github.com/cisco/libfnr/blob/master/test/bench.c)\r\n> ```\r\n> GCC v5.2.1 compiles with -O2 and use OpenSSL 1.0.2d\r\n> ```\r\n \r\n\r\n\r\nFNR is designed by Sashank Dara (sadara@cisco.com), Scott Fluhrer (sfluhrer@cisco.com).\r\n\r\nJava implementation was written by Mehmet Gurevin (mehmet.gurevin@octabase.com)\r\n\r\nCopyright (c) 2015-2016, Octabase, Inc. All Rights Reserved.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}